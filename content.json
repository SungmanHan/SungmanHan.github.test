{"meta":{"title":"일상개발","subtitle":"공부합시다","description":"개발 기록","author":"Sungman Han","url":"https://sungmanhan.github.io","root":"/"},"pages":[{"title":"","date":"2019-05-18T09:05:07.201Z","updated":"2019-05-18T09:05:07.201Z","comments":true,"path":"about/index.html","permalink":"https://sungmanhan.github.io/about/index.html","excerpt":"","text":"한성만입니다 학력 경력 관심 개발 분야 skill set list"}],"posts":[{"title":"Java Study 10","slug":"Java-Study-10","date":"2019-06-23T13:38:12.000Z","updated":"2019-06-23T13:41:44.955Z","comments":true,"path":"2019/06/23/Java-Study-10/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-10/","excerpt":"","text":"변수변수란? 변수(Variable)란, 하나의 값을 저장할 수 있는 메모리 상의 공간을 말한다. 변수는 값을 저장할 수 있는 메모리 공간을 의미한다.변수란 이름을 갖게 된이유는 프로그램에 의해서 수시로 값이 변동될 수 있기 때문이다. 변수에는 복수 개의 값을 저장할 수 없고,하나의 값만 저장할 수 있다.그리고 변수에는 다양한 타입의 값을 저장할 수 없고,한 가지 타입만 정의하여 사용할 수 있다. 변수의 선언12int age; // 정수(int)값을 저장할 수 있는 age변수를 선언double value; // 실수(dobule) 값을 저장할 수 있는 value 변수를 선언 변수를 사용하기 위해서는 먼저 변수를 선언해야 한다.어떤 타입(행태)의 값을 저장할 것이며,어떤 변수 명을 사용할 것인지 정해야 한다. 그리고 같은 타입의 변수는 콤마(,)를 이용해서 한꺼번에 선언할 수 있다. 동시 선언1int x,y,z; 하지만 위의 선언방법은 다른 개발자가 봤을 때,명확하게 볼 수 없기 때문에 각각 선언을 해주는 것이 좋다. 그리고 변수 명(이름)은 메모리(JVM이 확보한 메모리 공간) 주소에 붙여진 이름이다. 프로그램은 변수 이름을 통해서 메모리 주소를 접근하고,그곳에 값을 저장하거나 그곳에 있는 값을 읽는다. 명명 규칙 변수 이름은 자바 언어에서 정한 명명 규칙(Naming convention)을 따라야 한다. 작성 규칙 예 첫번째 글자는 문자이거나 ‘$’,’_’여야 하고 숫자로 시작할 수 없다.(필수) 가능 : price, $price, _companyName불가능 : 1v, @speed, $#value 영어 대소문자가 구분된다.(필수) firstname과 firstName은 다른 변수이다.첫문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫자를 대문자로 한다.(관례)maxSpeed,firstName,carBodyColor 등 문자 수(길이)는 제한은 없다. 너무 길면 다른 개발자가 보기 힘들다. 자바 예약어는 사용할 수 없다.(필수) 아래 사진 참고 예약어 Java는 예약어들로 변수 이름을 지정하면 컴파일 에러가 발생하기 때문에 주의해야 한다. 개발자는 변수 명을 보고,이 변수가 어떤 값을 저장하고 있는지 쉽게 알 수 있도록의미 있는 변수 명을 지어주는 것이 좋다(영어 명사).변수 이름은 길이는 프로그램 실행과는무관하기 때문에 충분히 길어도 상관없다. 그리고 개발자들 간에 지켜오는 관례가 있는데,관례란 개발자들 간의 코드 작성 패턴을 공유하고자 하는약속이기 때문에 가급적 지키는 편이 좋다. 변수 이름에 한글도 사용이 가능하지만 가급적이면,한글을 포함하지 않는 것이 좋다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"변수","slug":"변수","permalink":"https://sungmanhan.github.io/tags/변수/"},{"name":"naming convention","slug":"naming-convention","permalink":"https://sungmanhan.github.io/tags/naming-convention/"},{"name":"예약어","slug":"예약어","permalink":"https://sungmanhan.github.io/tags/예약어/"}]},{"title":"Java Study 09","slug":"Java-Study-09","date":"2019-06-23T13:36:49.000Z","updated":"2019-06-23T13:37:58.673Z","comments":true,"path":"2019/06/23/Java-Study-09/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-09/","excerpt":"","text":"타입 변환이란 데이터 타입을 다른 데이터 타입으로 변환하는 것을 말한다. 큰 타입과 작은 타입의 구분은 사용하는 메모리의 크기이다. 자동 타입 변환(Promotion)byte type(작은 타입) -&gt; int type(큰 타입)으로 변환하는 경우 강제 타입 변환(Casting)long type(큰 타입) -&gt; int type(작은 타입)으로 변환하는 경우 PromotionExample.java1234567891011121314151617181920212223242526// 자동 타입 변환 Promotion 예제코드public class PromotionExample &#123; public static void main(String[] args) &#123; byte byteValue = 10; int intValue = byteValue; //int &lt;- byte System.out.println(intValue); // 유니코드란 전 세계적으로 사용하는 모든 문자 집합을 하나로 모은 것이다. // Java의 경우 유니코드 기준으로 한다. char charValue = '가'; intValue = charValue; //int &lt;- char System.out.println(\"가의 유니코드 = \"+intValue); intValue = 500; long longValue = intValue; //long &lt;- int System.out.println(longValue); intValue = 200; double doubleValue = intValue; //double &lt;- int System.out.println(doubleValue); &#125;// .main&#125;// .class 자동 타입 변환이 발생되면 변환 이전의 값과 변환 이후의 값은 동일하다. 즉, 변환 이전의 값은 변환 이후에도 손실 없이 그대로 보존이된다. 이것은 작은 그릇의 물을 큰 그릇으로 옮기더라도 물의 양은 변하지 않는다는 것과 유사하다. CastingExample.Java1234567891011121314151617181920212223242526// 강제 타입 변환 예제코드public class CastingExample &#123; public static void main(String[] args) &#123; int intValue = 44032; char charValue = (char) intValue; // char &lt;- int System.out.println(charValue); long longValue = 500; intValue = (int) longValue; //int &lt;- long System.out.println(intValue); double doubleValue = 3.14; intValue = (int) doubleValue; //int &lt;- double System.out.println(intValue); // 값의 손실이 발생한다. // 103029700을 이진수로 표현하면 00000110 00100100 00011100 00001010이다. // 이 중 1byte 크기인 마지막 00001010인 값만 남기고 앞의 값은 보존되지 않아 값의 손실이 발생한다. intValue = 103029770; byte byteValue = (byte) intValue; //byte &lt;- int System.out.println(byteValue); &#125;// .main&#125;// .class 강제 타입 변환에서 주의할 점은 사용자로부터 입력받은 값을 변환할 때 값의 손실이 발생하면 안된다는 것이다. 강제 타입 변한을 하기 전에 우선 안전하게 값이 보존될 수 있는지 검사하는 것이 좋다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"자동 타입 변환","slug":"자동-타입-변환","permalink":"https://sungmanhan.github.io/tags/자동-타입-변환/"},{"name":"강제 타입 변환","slug":"강제-타입-변환","permalink":"https://sungmanhan.github.io/tags/강제-타입-변환/"}]},{"title":"Java Study 08","slug":"Java-Study-08","date":"2019-06-23T13:36:08.000Z","updated":"2019-06-23T13:36:39.686Z","comments":true,"path":"2019/06/23/Java-Study-08/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-08/","excerpt":"","text":"퍼스펙티브(Perspective)는 이클립스에서 프로젝트를 개발할 때 유용하게 사용하는 view들을 묶어 놓은 것을 말한다. Java Perspective에서 제일 많인 사용하는 뷰는 프로젝트를 관리하고, 자바 소스 파일을 생성 및 삭제하는 작업을 하는 Package Explorer View이다. 그리고 프로그램에서 콘솔로 출력하는 내용을 보여주는 Console view도 많이 사용된다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"perspective","slug":"perspective","permalink":"https://sungmanhan.github.io/tags/perspective/"},{"name":"이클립스","slug":"이클립스","permalink":"https://sungmanhan.github.io/tags/이클립스/"}]},{"title":"Java Study 07","slug":"Java-Study-07","date":"2019-06-23T13:26:41.000Z","updated":"2019-06-23T13:34:39.644Z","comments":true,"path":"2019/06/23/Java-Study-07/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-07/","excerpt":"","text":"문법 설명 // //부터 라인 끝까지 주석으로 처리 (행 주석) /**/ /와 /사이에 있는 모든 범위를 주석으로 처리 (범위 주석) 주석은 프로그램 실행과 상관없이 코드에 설명을 붙일 수 있다. 컴파일 과정에서 주석은 무시되고 실행문만 바이트 코드로 번역된다. 따라서 주석을 많이 작성한다고 해서 전체 프로그램의 크기가 커지는 것이 아니므로, 가급적 코드의 설명이 필요한 부분에 적절하게 주석을 달아 두는 것이 좋다. Hello.java 파일에 주석을 추가한 경우 Hello.java12345678910111213/*작성자 : 한성만작성일 : 2018-08-19*/public class Hello &#123; public static void main(String[] args)&#123; System.out.println(\"Hello world!\"); // 콘솔에 출력하는 실행문 &#125;// .main&#125;// .class 실행문은 변수 선언, 값 저장, 메소드 호출에 해당하는 코드를 말한다.실행문을 작성할 때 주의할 점은 실행문의 마직막에 반드시 세미콜론(;)을 붙여서 실행문이 끝났음을 표시해주어야 한다. 123int x = 1; // 변수 x를 선언하고 정수형 리터럴 1을 저장int y = 2; // 변수 y를 선언하고 정수형 리터럴 2을 저장int result = x + y; // 변수 result를 선언하고 변수 x와 y를 더한 값을 저장 컴파일러는 세미콜론(;)이 나올 때까지 실행문이 계속해서 연결된 것으로 보기 때문에 한 실행문이 여러 줄에 걸쳐 있어도 되고, 한 줄에 여러 개의 실행문이 있어도 된다. 예를 들어123int x = 1; int y = 2;int reuslt =x + y; 위의 예시처럼 선언은 가능 하나 가능하면 코드는 다른 사람이 보기 쉽게 작성하는 것이 좋다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"주석","slug":"주석","permalink":"https://sungmanhan.github.io/tags/주석/"},{"name":"세미콜론","slug":"세미콜론","permalink":"https://sungmanhan.github.io/tags/세미콜론/"},{"name":"실행문","slug":"실행문","permalink":"https://sungmanhan.github.io/tags/실행문/"}]},{"title":"Java Study 06","slug":"Java-Study-06","date":"2019-06-23T13:26:00.000Z","updated":"2019-06-23T13:32:08.170Z","comments":true,"path":"2019/06/23/Java-Study-06/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-06/","excerpt":"","text":"Java 실행 프로그램은 반드시 클래스(class) 블록과 main() 메소드(method) 블록으로 구성되어야 한다. 메소드 블록은 단독으로 작성될 수 없고 항상 클래스 블록 내무에서 작성되어야 한다. 클래스 : 필드 또는 메소드를 포함하는 블록메소드 : 어떤 일을 처리하는 실행문들을 모아 놓은 블록 Hello.java12345678910public class Hello &#123; // class 중괄호(브라킷) 블록 시작 // Hello 는 클래스의 이름이며 Hello.java 파일과 같아야 한다. // 숫자로 시작할 수 없고, 공백을 포함해서도 안된다. // public static void main(String[] args) = method 블록을 제외한 메소드 선언 부분을 메소드 시그니처라 한다. public static void main(String[] args) &#123; // main method 블록 시작 &#125; // .main 블록 종료&#125; // .class 블록 종료 main()는 java.exe로 JVM을 구동시키면 제일 먼저 main() 메소드를 찾아서 실행시키기 때문이다. 그래서 main() 메소드를 프로그램 실행 진입점 (entry point : starting point)라고 한다. 만약 클래스 내부에 main() 메소드가 없거나 잘못 작성하는 경우 에러가 발생한다. main error 경우 확인","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"java main","slug":"java-main","permalink":"https://sungmanhan.github.io/tags/java-main/"},{"name":"main method","slug":"main-method","permalink":"https://sungmanhan.github.io/tags/main-method/"},{"name":"java 프로그램 소스 분석","slug":"java-프로그램-소스-분석","permalink":"https://sungmanhan.github.io/tags/java-프로그램-소스-분석/"},{"name":"소스 분석","slug":"소스-분석","permalink":"https://sungmanhan.github.io/tags/소스-분석/"}]},{"title":"Java Study 05","slug":"Java-Study-05","date":"2019-06-23T13:24:20.000Z","updated":"2019-06-23T13:31:33.318Z","comments":true,"path":"2019/06/23/Java-Study-05/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-05/","excerpt":"","text":"java 소스 파일 작성 -&gt; 컴파일러(javac.exe)로 바이트 코드 파일(. class) 생성 -&gt; JVM 궁동 명령어 (java.exe)로 실행 자바 프로그램을 개발하기 위해서는 우선 파일 확장명이. java인 텍스트 파일을 생성하여 프로그램을 작성한다. window key + r -&gt; cmd 실행 cmd로 해보는 이유는 개발자는 개발 툴에 종속이 되어서는 안 되기 때문이다. cmd를 이용한 Hello.java 생성 123&gt; mkdir app // mkdir : c 드라이브에 app이라는 폴더를 생성한다. (생성전 위치는 c)&gt; cd app // cd : 생성한 app 폴더로 이동&gt; notepad Hello.java // notepad : 이동한 app 폴더에 Hello.java 파일 생성 Hello.java12345public class Hello &#123; public static void main(String [] args)&#123; System.out.println(\"Hello world!\"); &#125;&#125; 소스 파일 작성 시 주의사항1- 1라인에서 Hello의 H가 대문자로 작성되어야 한다(파일명과 대소문자가 동일해야 함)2- 2라인에서 String의 S가 대문자로 작성되어야 함(참조형 타입, 뒤에서 설명 일단 이렇게 알고 넘어가자)3- 3라인에서 System의 S가 대문자로 작성되어야 함 (OS가 제공하는 3가지 System.in / System.out / System.. err)4- 3라인 끝에는 세미콜론(;)을 붙여준다. 1234&gt; dir // dir : 현 위치에 생성된 파일리스트 조회 // 생성된 Hello.java 파일을 확인 가능&gt; javac Hello.java // 작성 완료된. java 소스 파일은 javac.exe로 컴파일해야 한다. 컴파일에 성공되면 확장명이. class 바이트 코드 파일은 완전한 기계어가 아니므로 단독으로 실행할 수 없고 JVM을 통해 실행해야 한다. JVM을 구동시키는 명령어는 java.exe 이다. 1&gt; java Hello // .class 확장명을 제외한 이름을 입력해야 함","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"개발 순서","slug":"개발-순서","permalink":"https://sungmanhan.github.io/tags/개발-순서/"},{"name":"Java 프로그램 개발 순서","slug":"Java-프로그램-개발-순서","permalink":"https://sungmanhan.github.io/tags/Java-프로그램-개발-순서/"},{"name":"프로그램 개발 순서","slug":"프로그램-개발-순서","permalink":"https://sungmanhan.github.io/tags/프로그램-개발-순서/"}]},{"title":"Java Study 04","slug":"Java-Study-04","date":"2019-06-23T13:15:31.000Z","updated":"2019-06-23T13:20:38.791Z","comments":true,"path":"2019/06/23/Java-Study-04/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-04/","excerpt":"","text":"JVM은 ‘Java를 실행하기 위한 가상 기계’라고 할 수 있다. ‘가상 기계 (Virtual Machine)’는 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어이다. 컴퓨터의 성능이 향상됨에 따라 점점 더 많은 하드웨어들이 소프트웨어화 되어 컴퓨터 속으로 들어오고 있다. 즉 ‘가상 기계(컴퓨터)’는 소프트웨어로 구현된 컴퓨터(하드웨어)가 아닌 소프트웨어로 구현된 컴퓨터라는 뜻으로 컴퓨터 속의 컴퓨터이다. Java로 작성된 애플리케이션은 모두 이 가상 컴퓨터(JVM)에서만 실행되기 때문에, 자바 애플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다. 일반 애플리케이션의 코드는 OS만 거치고 하드웨어로 전달되는데 비해 Java 애플리케이션은 JVM을 한 번 더 거치기 때문에. 그리고 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시에 해석(Interpret)되기 대문에 속도가 느리다는 단점을 가지고 있다. Java 애플리케이션은 JVM 하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 프로그램의 변경 없이 실행이 가능하다. 단, JVM은 OS에 종속적이기 때문에 해당 OS에서 실행 가능한 JVM이 필요하다. JVM 구조 Class Loader RunTime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 된다. Runtime Data Areas JVM이 프로그램을 수행하기 위해 OS로부터 별 도로 할당받은 메모리 공간을 말한다. Runtime Data Areas는 크게 5가지 영역으로 나눈다. PC Register 프로그램의 실행은 CPU에서 명령, 즉 instruction을 수행하는 과정으로 이루어진다. CPU는 이러한 instruction을 수행하는 동안 필요한 정보를 레디 스터라고 하는 CPU 내의 기억장치를 사용한다. Java의 PC Register는 CPU 내의 기억장치인 레지스터와는 다르게 작동한다. Register - Base 가 아닌 Stack - Base로 동작한다. PC Register는 각 Thread 별로 하나 씩 존재하며 현재 수행 중인 Java Virtual Machine instruction의 주소를 가지게 된다. 만일 Native Method를 수행한다면 PC Register는 Undefined 상태가 된다. 이 PC Register에 저장되는 instruction의 주소는 Native Pointer일 수도 있고 Method Byte code일 수도 있다. Native Method를 수행할 때에는 JVM을 거치지 않고 API를 통해 바로 수행하게 된다. 이 는 Java는 Platform에 종속받지 않는다는 것을 볼 수 있다. Java Virtual Machine Stack Java virtual Machine Stacks은 Thread의 수행 정보를 Frame을 통해서 저장하게 된다. Java Virtual Machine Stacks는 Thread가 시작될 때 생성되며, 각 Thread 별로 생성이 되기 때문에 다른 Thread는 접근할 수 없다. Method가 호출되면 Method 정보는 Stack에 쌓이게 되면 Method 호출이 종료될 때 Stack point에서 제거된다. Method 정보는 해당 Method의 매개변수, 지역변수, 임시 변수 그리고 어드레스(메서드 호출 한 주소) 등을 저장하고 Method 종료 시 메모리 공간이 사라진다. Native Method Stack Java 외의 언어로 작성된 Native code를 위한 Stack, 즉, JNI (Java Native Interface)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 Stack Native Method를 위해 Native Method Stack이라는 메모리 공간을 갖는다. Application에서 Native Method를 호출하게 되면 Native Method Stack에 새로운 Stack Frame을 생성하여 Push 한다. 이는 JNI를 이요하여 JVM 내부에 영향을 주지 않기 위함이다. Method Area 모든 스레드가 공유하는 메모리 영역이다. Method Area는 클래스, 인터페이스, 메서드, 필드, Static 변수 등의 Byte code 등을 보관한다. Heap 프로그램상에서 Runtime 시 동적으로 할당하여 사용하는 영역, class를 이용해 instance를 생성하면 Heap에 저장된다.(ex. Class A = new ClassA();) Execution Engine Load 된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine이다. Class Loader를 통해 JVM 내의 Runtime Data Areas에 배치된 바이트 코드는 Execution Engine에 의해 실행되며, 실행 엔진은 Java byte code를 명령어 단위로 읽어서 실행한다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://sungmanhan.github.io/tags/JVM/"}]},{"title":"Java Study 03","slug":"Java-Study-03","date":"2019-06-23T13:14:48.000Z","updated":"2019-06-23T13:20:42.041Z","comments":true,"path":"2019/06/23/Java-Study-03/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-03/","excerpt":"","text":"1. 이식성이 높은 언어이식성이란 서로 다른 실행 환경을 가진 시스템 간에 프로그램을 옮겨 실행할 수 있는 것을 말한다. Java는 실행 환경인 JRE(Java Runtime Environment)이 설치되어 있는 모든 운영체제에서 실행이 가능하다. 2. 객체 지향 언어 객체 지행 프로그래밍 OOP (Object Oriented Programming)이란 프로그램을 개발하는 기법으로 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법을 말한다. 이때 사용되는 언어를 객체 지향 언어라고 한다. Java는 객체 지향 언어가 가져야할 캡슐화, 상속, 다향성 기능을 완벽하게 지원하고 있다. 3. 함수적 스타일 코딩을 지원 함수적 프로그래밍은 대용량 데이터의 병렬 처리 그리고 이벤트 지향 프로그래밍을 위해 적합하다. 그래서 Java는 람다식 (Lambda Expressions)을 Java 8부터 지원한다. 람다식을 사용하면 컬렉션의 요소를 필터링, 매핑, 집게 처리하는데 쉬워지고, 코드가 매우 간결해진다. 4. 메모리를 자동으로 관리 객체 생성 시 자동적으로 메모리 영역을 찾아서 할당하고, 사용이 완료되면 쓰레기 수집기 (Garbage Collector)를 실행시켜 자동적으로 사용하지 않는 객체를 제거시켜준다. 따라서 개발자의는 메모리 관리의 수고스러움을 덜고, 핵심 기능 코드 작성에 집중할 수 있다. 5. 다양한 애플리케이션 개발 가능 Java는 다양한 운영체제 OS(Operating System)에서 실행되는 프로그램을 개발할 수 있다. Java는 다양한 OS에서 사용할 수 있는 개발 도구와 API를 묶어 Edition 형태로 정의하고 있다. 1. Java SE (Standard Edition) - 기본 에디션 Java SE는 Java program들이 공통적으로 사용하는 JVM (Java Virtual Machine)와 개발에 필수적인 도구와 Library API를 정의한다. 클라이언트와 서버 프로그램에 상관없이 Java program을 개발하고 실행하기 위해서는 반드시 Java SE 구현체인 JDK (Java Development Kit)를 설치해야 한다. 2. Java EE (Enterpirse Edition) - 서버용 애플리케이션 개발 에디션 Java EE는 분산 환경 ( 네트워크, 인터넷)에서 서버용 애플리케이션을 개발하기 ㅜ이한 도구 및 라이브러리 API를 정의한다. Servlet/JSP, EJB (Enterprise Java Bean), XML Web Services 등이 있다. 6. Multi-Thread하나의 프로그램이 동시에 여러 가지 작업을 처리해야 할 경우와 대용량 작업을 빨리 처리하기 위해 서브 작읍로 분리해서 병렬 처리하려면 멀티 스레드 프로그래밍이 필요하다. Java는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하기 있기 때문에 실행되는 운영체제 상관없이 멀티 스레드를 쉽게 구현한 수 있다. 7. Dynamic LoadingJava는 객체가 필요한 시점에 클래스를 동적로딩해서 객체를 생성한다. 또한 개발 오나료 후 유지보수(수정)가 발생하더라도 해당 클래스만 수정하면 되므로 전체 애플리케이션을 단시 컴파일할 필요가 없다. 따라 유지보수를 쉽고 빠르게 진행할 수 있다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/tags/Java/"},{"name":"이식성","slug":"이식성","permalink":"https://sungmanhan.github.io/tags/이식성/"},{"name":"객체 지향","slug":"객체-지향","permalink":"https://sungmanhan.github.io/tags/객체-지향/"},{"name":"함수적 코딩","slug":"함수적-코딩","permalink":"https://sungmanhan.github.io/tags/함수적-코딩/"},{"name":"메모리 관리","slug":"메모리-관리","permalink":"https://sungmanhan.github.io/tags/메모리-관리/"},{"name":"다양한 App 개발","slug":"다양한-App-개발","permalink":"https://sungmanhan.github.io/tags/다양한-App-개발/"},{"name":"Multi Thread","slug":"Multi-Thread","permalink":"https://sungmanhan.github.io/tags/Multi-Thread/"},{"name":"Dynamic Loading","slug":"Dynamic-Loading","permalink":"https://sungmanhan.github.io/tags/Dynamic-Loading/"}]},{"title":"Java Study 02","slug":"Java-Study-02","date":"2019-06-23T13:10:00.000Z","updated":"2019-06-23T13:20:48.499Z","comments":true,"path":"2019/06/23/Java-Study-02/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-02/","excerpt":"","text":"컴퓨터가 이해할 수 있는 기계어(machine language)는 0과 1로 이루어진 이진 코드이다. 이 언어는 사람이 이해하기 힘들다. 그렇기 때문에 사람의 언어와 기계어의 가교 역할을 하는 프로그래밍 언어가 필요하다. 사람의 측면에서 프로그래밍 언어는 고급 언어와 저급 언어로 구분된다. 사람이 이해할 수 있는 언어에 가까우면 고급 언어(High Level Language)라 하며, 기계어에 가까운 언어를 저급 언어(Low Level Language)라 한다. 저급 언어는 사람이 쉽게 이해할 수 없기 때문에 배우기가 매우 까다롭다. 사람이 고급 언어로 작성한 소스(source code)는 컴퓨터가 바로 이해할 수 없기 때문에 컴파일(compile) 과정을 통해서 컴퓨터가 이해할 수 있는 0과 1로 이루어진 기계어로 변환한 후 컴퓨터가 이해할 수 있게 된다. 일반 적으로 프로그램(program)이란 컴퓨터에서 특정 목적을 수행하기 위해 프로그래밍 언어로 작성된 소스를 기계어로 번역한 것을 의미한다. Java는 1991년도 Sun Engineer들에 의해서 고안된 Oak라는 언어에서 시작, 초기. Oak는 가전제품에 사용될 목적이었다. 그리고 1995년도에 처음 Sun Microsystems에서 Java 언어를 발표 지금까지 전세계적으로 사용중이다. 1999년도부터 인터넷이 활성화되면서 웹 애플리케이션 구축용 언어로 Java가 급부상했다. 이유는 다양한 서버 운영체제에서 단 한 번의 작성으로 모든 곳에서 실행 가능한 언어가 Java 뿐이었기 때문이다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/tags/Java/"}]},{"title":"Java Study 01","slug":"Java-Study-01","date":"2019-06-23T13:04:38.000Z","updated":"2019-06-23T13:11:56.565Z","comments":true,"path":"2019/06/23/Java-Study-01/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Java-Study-01/","excerpt":"","text":"Java란 무엇이며 왜 사용하는지 궁금한 분들은 초코토끼님의 “자바란 무엇일까요?”를 참고하기를 바란다. 123필요한 것들- jdk- eclipse 폴더 생성 프로젝트를 시작할 때 파일 관리가 중요하다. 여러 프로젝트를 진행하다 보면 중복되는 파일들이 있을 것이다. 이 것을 한 곳에 모아 중복을 최소화해서 관리하자. C:\\ 경로에 Dev 폴더 생성 : 개발에 필요한 공통적인 파일(Package)을 모으는 곳 D:\\ 경로에 Workspace 폴더 생성 : 작업 폴더를 관리하는 곳(여러 Java Project) 다운로드JDK 다운로드 아래 사진을 참고하여 Jdk 다운로드를 위해 라인센스 동의(Accept License Agreement) 후 PC환경에 맞는 파일을 다운로드한다. 다운로드 후 설치는 위에서 생성한 C:\\Dev에 설치한다. JDK : Java Development Kit 자바 개발을 위한 도구이다. 자바 컴파일러(Javac), 자바 가상 머신(JVM), 각종 Java Library 등을 포함하고 있어서 자바 개발을 위한 필수 도구이다. JDK는 JRE를 포함하고 있다.(JDK 설치 시 JRE도 설치됨) JRE : Java Run Environment 자바 실행 환경이다. Java 파일 실행을 위한 환경이며 JVM이 실행되도록 도와주는 역할을 한다. 만약 자바 개발이 필요 없고 실행만을 원한다면 JRE만 설치하고 Java 파일을 실행하면 된다. JVM : Java Virtual Machine 사용자가 Java 파일을 생성한 후 JDK의 컴파일을 거쳐 바이트코드(.class)가 되어 JVM을 거치면 컴퓨터가 사용할 수 있는 기계어로 변경해주는 역할을 한다. 자바 실행 흐름 사용자 .java source파일 생성 -&gt; JDK 컴파일(.class 파일 생성) -&gt; JVM(기계어 변환) -&gt; 실행 Java 환경 변수 라떼베리님의 “자바 환경변수 설정 (윈도10)”을 참고하기를 바란다. 1MAC OS의 경우 IT김군님의 &lt;a href=&quot;http://devkimgoon.tistory.com/3&quot; target=&quot;_black&quot;&gt;&quot;MAC OS X에서 Java 설치하기 및 환경변수 설정&quot;&lt;/a&gt;을 참고하기를 바란다. IDE : Integrated Development Environment IDE는 통합 개발 환경으로 코딩, 디버그, 컴파일, 배포 등 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 소프트웨어이다. Eclipse 또한 IDE의 하나의 종류이다. Eclipse 다운로드 통합 개발 환경인 Eclipse 다운로드한다. 여기서 Eclipse IDE for Java EE Developers로 다운로드 받으면 된다. 이공잉님의 Windows에서 Eclipse 설치 및 실행 이공잉님의 OS X에서 Eclipse 설치 및 실행 지금까지 Java 개발을 시작하기 위해 JDK와 IDE-Eclipse 설치 방법을 알아봤다. 사실 더 많은 정보를 작성하고 싶었지만… 이미 설명을 잘 해주신 분들이 있기 때문에 흐름만을 나열해 봤다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sungmanhan.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://sungmanhan.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://sungmanhan.github.io/tags/jdk/"},{"name":"eclipse","slug":"eclipse","permalink":"https://sungmanhan.github.io/tags/eclipse/"},{"name":"java path","slug":"java-path","permalink":"https://sungmanhan.github.io/tags/java-path/"}]},{"title":"Hexo & Git Blog 05","slug":"Hexo-Git-Blog-05","date":"2019-06-23T12:06:15.000Z","updated":"2019-06-23T12:56:37.959Z","comments":true,"path":"2019/06/23/Hexo-Git-Blog-05/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Hexo-Git-Blog-05/","excerpt":"","text":"문득 지금까지 만든 만든 블로그에 사람들이 얼마나 왔을까? 문득 궁금해졌다. 그래서 일단 찾아봤다. 누군가는 만들었겠지…. 역시 누군가는 만들었다. ㅎㅎㅎ hexo로 생성된 블로그에 총 방문자수, 단일 페이지 방문수, 카운트 등 나의 궁금한 부분을 해결할 수 있는 busuanzi를 찾게 되었다. (대체 방법은 Google의 웹 로그 분석도 가능함) 12345위의 busuanzi링크를 접속하면.....중국어다...Google 한글 번역 화이팅!! 마늘이 귀엽다.. busuanzi의 적용 방법은 정말 간단하다. 1. 스크립트 추가 아래의 코드를 원하는 곳에 추가하면 된다. 필자는 themes/bootstrap-blog/layout/_partial/footer.ejs에서 &lt;footer&gt; 바로 아래에 스크립트를 추가할 것이다. 1&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2. 카운터 코드 추가busuanzi에서 번역을 돌려보면 알겠지만 여러 가지 카운터가 있다. 그중 총 조회 수 와 총 방문자 수를 두 가지를 추가할 것이다. 필자는 themes/bootstrap-blog/layout/_partial/footer.ejs에 적절한 위치에 아래의 코드를 추가할 것이다. 123456&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 총 조회 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 회&lt;/span&gt; |&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 총 방문자 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 명&lt;/span&gt; 보통 이런 카운터 기능은 사이트에 얼마나 많은 사람들이 방문했는지 확인 또는 표시를 하며, 사이트의 인지도를 보는 하나의 지표로 사용한다.","categories":[{"name":"Github & hexo","slug":"Github-hexo","permalink":"https://sungmanhan.github.io/categories/Github-hexo/"}],"tags":[{"name":"busuanzi","slug":"busuanzi","permalink":"https://sungmanhan.github.io/tags/busuanzi/"},{"name":"hexo counter","slug":"hexo-counter","permalink":"https://sungmanhan.github.io/tags/hexo-counter/"},{"name":"counter","slug":"counter","permalink":"https://sungmanhan.github.io/tags/counter/"}]},{"title":"Hexo & Git Blog 04","slug":"Hexo-Git-Blog-04","date":"2019-06-23T12:03:57.000Z","updated":"2019-06-23T12:51:06.724Z","comments":true,"path":"2019/06/23/Hexo-Git-Blog-04/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Hexo-Git-Blog-04/","excerpt":"","text":"Disqus는 소셜 댓글 서비스로, 댓글을 직접 구현하지 않소 위젯의 형태로 서비스에 삽입할 수 있다. 지금 까지 만들어온 정적인 블로그에 Disqus는 댓글 서비스를 적용할 것을 나열하겠다. 1Disqus는 일정 용량이 초과 화면 유료화 된다. 유료화가 된 다는 것은 나의 블로그가 성공했다고 볼 수 있지 않을까?? Disqus에서 회원 가입을 하면, 자신의 댓글 위젯을 사용할 수 있는 생태가 된다. 영상을 좋아하는 분은 아래의 영상을 참고하기를 바란다. (이고잉님의 댓글 서비스(disqus)) 1. Disqus 회원 가입 Disque 회원 가입을 먼저 한다. 2. Disqus로 무엇을 할 것인가? 회원 가입 후 Get Started를 누르면 , I want to comment on sites와 I want to install Disqus on my site가 나온다 두 번째 I want to install Disqus on my site를 선택한다. 사이트 이름과 카테고리를 설정하고 create 한다. 3. Install Disqus Disqus 사이트를 생성하면 첫 화면에서 2. Install Disqus를 선택하고, Select Platform에서 어느 플랫폼을 이용하는지 물어보는 부분이 나온다. 우리는 hexo에 직접 코드를 삽입할 것으로 스크롤을 내리면 하단에 I don’t see my platform listed, install manually with Universal Code를 선택한다. 4. Code 적용하기 필자는 생성된 코드를 themes/bootstrap-blog/layout/_partial/article.ejs에서 하단에 아래의 코드를 삽입할 것이다. 123456789101112131415161718192021222324252627&lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;&lt;/section&gt;&lt;script&gt;/*** RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*//*var disqus_config = function () &#123;this.page.url = PAGE_URL; // Replace PAGE_URL with your page&apos;s canonical URL variablethis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page&apos;s unique identifier variable&#125;;*/(function() &#123; // DON&apos;T EDIT BELOW THIS LINEvar d = document, s = d.createElement(&apos;script&apos;);s.src = &apos;https://hansungman2.disqus.com/embed.js&apos;;s.setAttribute(&apos;data-timestamp&apos;, +new Date());(d.head || d.body).appendChild(s);&#125;)();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; 그리고 themes/bootstrap-blog/layout/layout.ejs에서 &lt;/body&gt; 바로 위에 하단의 코드를 추가한다. (하단의 코드는 ) 1&lt;script id=&quot;dsq-count-scr&quot; src=&quot;//hansungman2.disqus.com/count.js&quot; async&gt;&lt;/script&gt; 5. 마지막으로… 마지막으로 root/_config.yml에 disqus_shortname을 넣고 해당 내용에 아까 위에 코드를 추가한다. 123# for Disqus# Docs : https://hansungman2.disqus.com/admin/install/platforms/universalcode/disqus_shortname: &#123;사이트 생성 이름&#125; 지금 까지 Disqus 소셜 댓글 서비스를 적용해봤다. 조금씩 블로그에 필요한 부분들이 채워지고 있다. 다음에는 나의 블로그에 방분자 수를 Count 하는 기능을 추가해 볼 것이다.","categories":[{"name":"Github & hexo","slug":"Github-hexo","permalink":"https://sungmanhan.github.io/categories/Github-hexo/"}],"tags":[{"name":"Disqus","slug":"Disqus","permalink":"https://sungmanhan.github.io/tags/Disqus/"},{"name":"댓글","slug":"댓글","permalink":"https://sungmanhan.github.io/tags/댓글/"},{"name":"소셜 댓글","slug":"소셜-댓글","permalink":"https://sungmanhan.github.io/tags/소셜-댓글/"}]},{"title":"Hexo & Git Blog 03","slug":"Hexo-Git-Blog-03","date":"2019-06-23T12:03:53.000Z","updated":"2019-06-23T12:58:52.701Z","comments":true,"path":"2019/06/23/Hexo-Git-Blog-03/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Hexo-Git-Blog-03/","excerpt":"","text":"블로그 생성 및 포스트 정보를 원한다면, hexo를 이용한 github 블로그 관리를 참하기를 바란다. 이전 포스트에서 Github &amp; hexo를 이용하여 정적인 개인 블로그를 만들어 봤으며, new post를 하는 부분까지 봤었다. 추가로 설명할 부분이 있다. 포스트 생성 방법command line에서 새로운 포스트를 생성하는 명령에서 설명을 하지 않은 옵션이 있다. 바로 layout 옵션이다. 12345// 이전에 설명한 명령어hexo new &lt;title&gt;// 기본 명령어hexo new [layout] &lt;title&gt; layout 옵션은 총 3가지가 있다. 각 옵션마다 생성되는 파일의 경로와 의미가 다르다. layout을 생략할 경우 기본은 post로 생성된다. Layout Path post source/_post page source draft source/_drafts 기본 레이아웃은 _config.yml에서 default_layout에서 변경이 가능하다. Post 홈페이지에 게시되는 기본적인 글이다. 기존 블로그에서 새 글 작성과 같다. Page Post 처럼 새 글을 추가하는 것이 아닌 해당 경로에 접근해야 볼 수 있는 페이지 이다. Draft 바로 게시하지 않고 작성할 수 있는 초안이다. Post를 작성할 때 먼저 초안으로 작성하고, 다 작성한 후에 publish 명령어로 배포하는 형식으로 게시한다. 여러 개의 Post를 작성 중일 때, 바로 반영 안 할 포스트는 로컬에 따로 저장해놨다가 나중에 반영할 때 사용한다. draft 실행1hexo server --draft 각각의 layout type에 기본 설정이 가능하다. 위치는 root/ scaffolds에 layout 파일들이 있다. 그리고 markdown 작성에 익숙하지 않다면 이곳을 참고해봐도 좋다. Theme 적용하기 지금부터 hexo에 테마를 적용할 것이다. 필자는 bootstrap-blog 테마를 사용하고 약간의 커스텀을 했다. 이유는 bootstrap이 경험도 있고 편하기 때문이다. ㅎㅎㅎ 그리고 직접 테마를 만들고 싶다면 이곳을 참고하기를 바란다. 이곳의 내용을 이해한다면 블로그의 테마를 수정하는 것은 아주 쉬울 것이다. 그리고 아주 친절하게 잘 설명이 되어있다. 1. install theme 우선 bootstrap-blog theme를 자신의 theme 폴더에 clone 한다. 1git clone https://github.com/cgmartin/hexo-theme-bootstrap-blog.git themes/bootstrap-blog 2. Optonal install npm 테마에 필요한 패키지를 설치한다. 12npm i hexo-tag-bootstrap --savenpm i hexo-tag-fontawesome --save 3. _config.yml에서 테마 변경 _config.yml에서 테마를 boostrap-blog로 변경한다. 4. 테마 업데이트12cd themes/bootstrap-bloggit pull 여기까지 했다면 기본적으로 새로운 테마를 받고 설정하고 필요한 패키지들을 설치하고 마지막으로 테마 업데이트 까지 했을 것이다. 5. 설정 각각의 테마에도 설정파일이 따로 있다. 몇 가지 속성들을 설명하겠다. Title description navbar_brand 사이트 왼쪽 상단의 자신만의 로그를 추가할 수 있다. 기본은 false이며, 넣는 방법은 img tag를 사용한다. 여기서 주의할 점은 경로이다. 기본 root는 theme/bootstrap-blog/source 이며, 이미지 폴더를 따로 만들어서 관리하는 것이 좋다. menu 페이지 상단의 메뉴를 추가할 수 있다. 위에서 설명한 layout 중에 page를 사용하는 부분에 해당될 수 있다. widgets 블로그의 sidebar에 있는 항목 들이다. bootstrap-blog 테마 이미지 경로 그리고 블로그의 기본 root에서 theme_config를 추가하여 설정할 수 있다. 휴 작성하다 보니 벌써 시간이 새벽이 되었다. 하루에 하나의 포스트를 작성하는 일이 쉬운 일은 아닌 듯하다. 지금 까지 Gitbut &amp; hexo를 이용한 정적 개인 블로그를 만들어 봤다. 혹시 궁금 한 점 또는 잘못된 정보가 있을 경우 알려주기를 바라다.","categories":[{"name":"Github & hexo","slug":"Github-hexo","permalink":"https://sungmanhan.github.io/categories/Github-hexo/"}],"tags":[{"name":"테마 적용","slug":"테마-적용","permalink":"https://sungmanhan.github.io/tags/테마-적용/"},{"name":"글쓰기 폼 수정","slug":"글쓰기-폼-수정","permalink":"https://sungmanhan.github.io/tags/글쓰기-폼-수정/"}]},{"title":"Hexo & Git Blog 02","slug":"Hexo-Git-Blog-02","date":"2019-06-23T12:03:49.000Z","updated":"2019-06-23T12:57:29.394Z","comments":true,"path":"2019/06/23/Hexo-Git-Blog-02/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Hexo-Git-Blog-02/","excerpt":"","text":"지금까지 Github &amp; hexo 블로그 준비하면서 필요한 설치 및 계정 생성을 하였다. 지금부터는 npm을 이용하여 hexo를 설치하고 환경설정 및 포스트 작성을 나열해보겠다. Github로 블로그를 관리하는 대표적인 프레임워크 Jekyll와 Hexo가 있다. 이 두 서비스는 블로그 관리에 최적회 되어있는 프레임워크이다. 필자는 둘 다 시도를 해봤고, Jekyll는 ruby기반이어서 좀 힘들었다. Hexo의 단점은 작성한 post의 버전 관리가 되지 않는다. post의 버전 관리를 중시하는 분에게는 이 부분이 치명적인 단점이 될 수 있다. 필자는 mac 기준으로 hexo설치 및 설정법을 나열 해보겠다.(Windows도 설치 및 설정하는 방법은 같다.) Hexo let’s go hexo Hexo는 Github 블로그를 빠르고 간단하게 관리할 수 있는 프레임워크이다. Node.jp를 이용하여 많은 패키지를 관리하고 빌드할 수 있으며, Command line에서 간단한 명령어로 Github에 deploy를 할 수 있다. 그리고 커스텀하기가 쉬우며 다양한 플러그인들이 있다. Hexo 설치 및 블로그 생성 npm을 통해 hexo를 글로벌 설치1npm install hexo-cli -g 블로그 생성 및 npm 설치123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 설치 과정123456sungui-MacBook-Air:~ sunghan$ hexo init my_blogINFO Cloning hexo-starter to ~/my_blogCloning into &apos;/Users/sunghan/my_blog&apos;......found 0 vulnerabilitiesINFO Start blogging with Hexo! 설치가 끝나면 아래 사진처럼 root에 설치된 것을 볼 수 있다. 생성된 폴더 구조12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 로컬 서버실행1hexo server 실행하고 보면 기본 landscape 테마가 적용된 블로그를 볼 수 있다. 로컬에서 실행된 화면 확인 http://localhost:4000/ 블로그 정보 package.json package.json 파일은 우리가 방금 만든 블로그의 정보와 npm을 이용하여 설치한 패키지 정보를 볼 수 있다. 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.7.1&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;hexo-browsersync&quot;: &quot;^0.3.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;, &quot;hexo-renderer-jade&quot;: &quot;^0.4.1&quot;, &quot;hexo-renderer-markdown&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-pug&quot;: &quot;0.0.5&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.3.2&quot;, &quot;hexo-tag-bootstrap&quot;: &quot;^0.1.2&quot;, &quot;hexo-tag-fontawesome&quot;: &quot;^1.0.0&quot; &#125;&#125; 블로그 _config.yml _config.yml은 블로그 생성을 완료하면 root 디렉터리에 생성되며, 블로그의 대부분의 설정을 할 수 있다. 자세한 설명은 Docs에서 확인하기를 바란다. 그럼 _config.yml에서 블로그 설정을 하나씩 하자. 나의 블로그 정보나의 블로그 소개와 간략한 블로그 내용 등을 작성 및 수정할 수 있다.html에서 head안에 들어가는 부분이다.1234567891011# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 느리더라도 꾸준하게subtitle: 토끼를 이긴 거북이description: 느리더라도 천천히 성장하는 한성만입니다.author: Sungman Hanlanguage: kotimezone: Asia/Seoul Gitbub URL 정보우리가 이전에 Github 계정을 생성하고 정적 페이지를 만들었던 URL 정보를 작성한다.123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://sungmanhan.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 나의 Github 정보나의 Github의 repositor 정보를 작성한다. 아래 사진에서 확인 가능하다. 아래와 같이 입력하면 된다. 꼭 branch에 master로 입력하기를 바란다. 그러면 간편하게 git push가 가능하다.123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/SungmanHan/SungmanHan.github.io.git branch: master 추가적으로정적 페이지를 배포하기 위해 hexo-deployer-git 플러그인이 필요하다. 아래의 명령어를 입력하여 플러그인을 추가하기를 바란다.1npm i hexo-deployer-git --save 정적생성 및 배포로컬에서 정적으로 생성한 블로그를 나의 Github page Repository에 배포해보자. 123456789101112// 정적페이지 생성hexo generate// github에 배포hexo deploy// 페이지 생성 및 배포를 동시에hexo deploy --generate// 배포를 했지만 페이지가 업데이트가 되지 않았다면hexo cleanhexo deploy --generate 새로운 포스트 작성hexo 블로그를 만들었으니 post를 작성하는 법을 알아보자. post를 작성하기 위해서는 command line을 통해 post를 새로 생성한 뒤 editor 상용하여 작성하면 된다. (필자는 atom editor를 사용한다.) new post새로운 포스트를 생성은 hexo new post &lt;post_name&gt;를 입력하면 된다.혹시나 하는 마음으로 “hexo ***” 등의 명령어는 해당 디렉터리로 이동해서 명령어를 입력하기를 바란다.1hexo new post &lt;post_name&gt; Examcommand lined에 명령어를 입력하면1hexo new &quot;my first post&quot;이렇게 성생된 post를 볼 수 있다. 지금까지 Github &amp; hexo를 이용하여 정적인 개인 블로그를 만들고 post를 생성하는 법을 알아봤다. 다음에는 bootstarp-blog 테마를 지금 만든 블로그에 적용해보고 약간의 기능 추가 및 커스텀을 나열 해보겠다.","categories":[{"name":"Github & hexo","slug":"Github-hexo","permalink":"https://sungmanhan.github.io/categories/Github-hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sungmanhan.github.io/tags/hexo/"},{"name":"블로그 관리","slug":"블로그-관리","permalink":"https://sungmanhan.github.io/tags/블로그-관리/"},{"name":"hexo 블로그","slug":"hexo-블로그","permalink":"https://sungmanhan.github.io/tags/hexo-블로그/"}]},{"title":"Hexo & Git Blog 01","slug":"Hexo-Git-Blog-01","date":"2019-06-23T12:01:52.000Z","updated":"2019-06-23T12:03:14.686Z","comments":true,"path":"2019/06/23/Hexo-Git-Blog-01/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/Hexo-Git-Blog-01/","excerpt":"","text":"기본 지식에 대하여 혹시 개발자가 아니어도 Github page를 이용하여 자신만의 블로그나 사이트를 운영기 원한다면, “생활코딩의 github를 웹호스팅으로 이용하기”의 내용을 먼저 이해하기를 바란다. 그리고 블로그의 테마를 본인이 직접 만들거나 수정하고 싶거나 어떤 기능을 추가하고 싶다면 “WENn(생활코딩) – 쌩기초부터 웹 사이트 구축까지”를 공부하기를 바란다. 사설.. 우리는 인터넷만 있다면 쉽게 원하는 정보를 얻을 수 있다. 물론 유료 정보가 있지만 무료도 좋은 정보들이 많다. 그리니 좋은 정보들을 잘 활용하기를 바란다.(필자도 개인적으로 정리를 하면서 블로그에 남길 생각하고 있다.) 잠깐 사설이 길어졌다.우리는 지금 Github &amp; hexo를 이용하여 정적인 개인 블로그를 만들 것이다. 만들기 전에 준비해야 하는 부분이 있다.개인 노트북 또는 PC에는 git, node를 설치해야 하며, Github 계정과 Disqus 계정 등이 필요하다. 그리고 hexo를 이용하여 쉽게 블로그를 관리할 것이다. 준비할 것들 다운로드 우선 순서대로 다운로드를 하기를 바란다. OS 상관없이 git 다운로드를 할을 수 있다. OS 상관없이 node 다운로드를 할을 수 있다. 자 다운로드를 하였다면 먼저 command를 이용해 git 계정을 설정해야 한다. 12git config --global user.name &quot;깃허브네임&quot;git config --global user.email &quot;깃허브이메일&quot; 혹시 mac을 사용하면서 필자처럼 mac을 접한 기간이 짧지만 command를 이용하겠다면, 회복맨 블로그에서 “[깃허브(Github)] 1-2. 맥(OS X) 설치”와 JOSHBERRY 블로그 “HOMEBREW를 이용하여 GIT 설치하기” 및 “개발자를 위한 맥(Mac) 정보 - 패키지관리자 Homebrew”에서 참고하기를 바란다. 설치된 버전들을 꼭 확인해보기 123$ git --version$ node -v$ npm -v 계정 생정 1. github 가입 가입은 일반 사이트에서 회원 가입하는 것과 비슷하다. 우선 Github에 들어가면 바로 가입이 가능하다. (사용자 이름과 이메일 그리고 비밀번호를 입력하면 가입) 2. github 프로젝트 생동적 페이지를 만들기 위해 먼저 repository를 생성한다. 생성 방법 New Repository, Repository 이름은 USERNAME.github.io USERNAME 은 Github의 가입 시에 사용자의 username을 입력한다 Public / Private 중 Public 선택 Create Repository 버튼을 통해 Repository 생성 Owner 이름은 본인의 이름을 하기를 바란다.본인ID.github.io 라는 이름으로 프로젝트를 생성하면, master 브랜치에 업로드하는 것으로 바로 배포된다.생성하고 나면 repository의 setting 정보를 확인할 수 있다.생성된 url로 접속하면 정적 페이지가 생성된 것을 확인할 수 있다. 다음에는 nmp을 통해서 hexo를 설치 및 기본적인 기능을 알아보겠다.","categories":[{"name":"Github & hexo","slug":"Github-hexo","permalink":"https://sungmanhan.github.io/categories/Github-hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sungmanhan.github.io/tags/git/"},{"name":"Github","slug":"Github","permalink":"https://sungmanhan.github.io/tags/Github/"},{"name":"hexo","slug":"hexo","permalink":"https://sungmanhan.github.io/tags/hexo/"}]},{"title":"마크다운","slug":"마크다운","date":"2019-06-23T11:36:17.000Z","updated":"2019-06-23T11:52:39.242Z","comments":true,"path":"2019/06/23/마크다운/","link":"","permalink":"https://sungmanhan.github.io/2019/06/23/마크다운/","excerpt":"","text":"마크다운(Markdown) 마크다운(Markdown)은 마크업 언어의 일종으로, John Gruber와 Aaron Swartz가 창안하였다. 마크다운의 장점 문법이 쉽다. 관리가 쉽다. 지원 가능한 플랫폼 및 프로그램이 다양하다. 마크다운의 단점 표준이 없다. 모든 HTML 마크업을 대신하지 못한다. 마크다운의 사용메모장부터 전용 에디터까지 많은 곳에서 활용할 수 있다. 문법이 쉽기 때문에 꼭 전용 에디터를 사용할 필요는 없다. 마크다운 코드와 하이라이트 효과를 원한다면 전용 에디터가 좋은 선택이 될 수 있다. (Atom) 마크다운 문법(Syntax)제목(Header)123456789101112# 1 제목 , &lt;h1&gt; &lt;/h1&gt;## 2 제목 , &lt;h2&gt; &lt;/h2&gt;### 3 제목 , &lt;h3&gt; &lt;/h3&gt;#### 4 제목 , &lt;h4&gt; &lt;/h4&gt;##### 5 제목 , &lt;h5&gt; &lt;/h5&gt;###### 6 제목 , &lt;h6&gt; &lt;/h6&gt;1과 2는 아래와 같이 표현 가능1 제목 // h1수준의 제목=====2 제목 // h2수준의 제목----- 1 제목2 제목3 제목4 제목5 제목6 제목1 제목2 제목 인용문 (Blockquote)123&gt; 인용문 1&gt;&gt; 인용문 2&gt;&gt;&gt; 인용문 3 인용문 1 인용문 2 인용문 3 목록 (List)순서가 있는 목록12341. 첫번째 1. 첫번째 자식2. 두번째3. 세번쨰 첫번째 두번째 세번쨰 순서가 없는 목록1234567891011* 별 * 별 * 별+ 더하기 + 더하기 + 더하기- 빼기 - 빼기 - 뺴기 별 별 별 더하기 더하기 더하기 빼기 빼기 뺴기 글자모양굵은1**굴게** 쓰거나 __두껍게__ 쓰거나 굴게 쓰거나 두껍게 쓰거나 기울임1*기울게* 쓰면서 _기울게_ 쓴다 기울게 쓰면서 기울게 쓴다 수평선12345678---(Hyphens)***(Asterisks)___(Underscores) (Hyphens) (Asterisks) (Underscores) 링크12345678910111213141516171819[GOOGLE](https://google.com)[NAVER](https://naver.com &quot;링크 설명(title)을 작성하세요.&quot;)[상대적 참조](../users/login)[Dribbble][Dribbble link][GitHub][1]문서 안에서 [참조 링크]를 그대로 사용할 수도 있습니다.다음과 같이 문서 내 일반 URL이나 꺾쇠 괄호(`&lt; &gt;`, Angle Brackets)안의 URL은 자동으로 링크를 사용합니다.구글 홈페이지: https://google.com네이버 홈페이지: &lt;https://naver.com&gt;[Dribbble link]: https://dribbble.com[1]: https://github.com[참조 링크]: https://naver.com &quot;네이버로 이동합니다!&quot; GOOGLE NAVER 상대적 참조 Dribbble GitHub 문서 안에서 참조 링크를 그대로 사용할 수도 있습니다. 다음과 같이 문서 내 일반 URL이나 꺾쇠 괄호(&lt; &gt;, Angle Brackets)안의 URL은 자동으로 링크를 사용합니다.구글 홈페이지: https://google.com네이버 홈페이지: https://naver.com 이미지12345![대체 텍스트(alternative text)를 입력하세요!](http://www.gstatic.com/webp/gallery/5.jpg &quot;링크 설명(title)을 작성하세요.&quot;)![Kayak][logo][logo]: http://www.gstatic.com/webp/gallery/2.jpg &quot;To go kayaking.&quot; 이미지 링크1[![Vue](logo.jpeg)](https://kr.vuejs.org/) 코드인리인 코드 강조1`background`혹은 `background-image` 속성으로 요소에 배경 이미지를 삽입할 수 있습니다. background혹은 background-image 속성으로 요소에 배경 이미지를 삽입할 수 있습니다. 블록 코드 강조12345678910111213141516171819202122232425262728293031```html&lt;a href=&quot;https://www.google.co.kr/&quot; target=&quot;_blank&quot;&gt;GOOGLE&lt;/a&gt;``````css.list &gt; li &#123; position: absolute; top: 40px;&#125;``````javascriptfunction func() &#123; var a = &apos;AAA&apos;; return a;&#125;``````bash$ vim ./~zshrc``````pythons = &quot;Python syntax highlighting&quot;print s``````No language indicated, so no syntax highlighting.But let&apos;s throw in a tag.``` html1&lt;a href=\"https://www.google.co.kr/\" target=\"_blank\"&gt;GOOGLE&lt;/a&gt; css1234.list &gt; li &#123; position: absolute; top: 40px;&#125; javascript1234function func() &#123; var a = 'AAA'; return a;&#125; bash1$ vim ./~zshrc python12s = \"Python syntax highlighting\"print s 12No language indicated, so no syntax highlighting.But let&apos;s throw in a tag. 표12345678910111213| 값 | 의미 | 기본값 ||---|:---:|---:|| `static` | 유형(기준) 없음 / 배치 불가능 | `static` || `relative` | 요소 자신을 기준으로 배치 | || `absolute` | 위치 상 부모(조상)요소를 기준으로 배치 | || `fixed` | 브라우저 창을 기준으로 배치 | |값 | 의미 | 기본값---|:---:|---:`static` | 유형(기준) 없음 / 배치 불가능 | `static``relative` | 요소 **자신**을 기준으로 배치 |`absolute` | 위치 상 **_부모_(조상)요소**를 기준으로 배치 |`fixed` | **브라우저 창**을 기준으로 배치 | 값 의미 기본값 static 유형(기준) 없음 / 배치 불가능 static relative 요소 자신을 기준으로 배치 absolute 위치 상 부모(조상)요소를 기준으로 배치 fixed 브라우저 창을 기준으로 배치 값 의미 기본값 static 유형(기준) 없음 / 배치 불가능 static relative 요소 자신을 기준으로 배치 absolute 위치 상 _부모_(조상)요소를 기준으로 배치 fixed 브라우저 창을 기준으로 배치","categories":[{"name":"TIP","slug":"TIP","permalink":"https://sungmanhan.github.io/categories/TIP/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://sungmanhan.github.io/tags/markdown/"},{"name":"markdown syntax","slug":"markdown-syntax","permalink":"https://sungmanhan.github.io/tags/markdown-syntax/"}]}]}